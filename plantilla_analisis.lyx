#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xmpmulti}
\usepackage{algorithm,algpseudocode}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "beramono" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 60 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Taller 4- 
\lang spanish
Busca
\lang english
 
\lang spanish
minas
\end_layout

\begin_layout Author
Alejandro 
\lang spanish
Salamanca
\lang english
, Andrés Salamanca
\end_layout

\begin_layout Date

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Abstract

\lang spanish
El informe presenta dos enfoques algorítmicos para abordar el desafío del
 juego de buscaminas, el cual se caracteriza por ser un problema NP-completo.
 
\end_layout

\begin_layout Abstract

\lang spanish
El primer algoritmo propuesto es el de fuerza bruta, que consiste en generar
 y evaluar exhaustivamente todas las combinaciones posibles de movimientos
 para encontrar una solución al juego.
 
\end_layout

\begin_layout Abstract

\lang spanish
El segundo algoritmo se basa en la aplicación de una heurística para guiar
 la búsqueda hacia una solución plausible del juego.
 Esta estrategia busca reducir la complejidad del problema al considerar
 únicamente movimientos prometedores según la heurística empleada.
\end_layout

\begin_layout Abstract

\lang spanish
El análisis comparativo entre ambos algoritmos se centra en la evaluación
 del tiempo de ejecución y la calidad de las soluciones obtenidas por cada
 uno.
 Esta comparación permitirá determinar la eficacia y la eficiencia relativa
 de cada enfoque en la resolución del juego de buscaminas.
\end_layout

\begin_layout Part

\lang spanish
Análisis y diseño del problema
\end_layout

\begin_layout Section

\lang spanish
Análisis
\end_layout

\begin_layout Standard

\lang spanish
El problema del busca minas se presenta como un desafío complejo en el que
 los jugadores deben encontrar soluciones óptimas para completar el juego
 con éxito.
 En este juego, se despliega un tablero de dimensiones 
\begin_inset Formula $N\times M$
\end_inset

 que es representado por una matriz 
\begin_inset Formula $A$
\end_inset

, y se esconden 
\begin_inset Formula $X$
\end_inset

 minas , donde 
\begin_inset Formula $N,M,X\in\mathbb{N}$
\end_inset

.
\end_layout

\begin_layout Standard

\lang spanish
El tablero, conformado por 
\begin_inset Formula $N$
\end_inset

 filas y 
\begin_inset Formula $M$
\end_inset

 columnas, representa el campo de juego donde se encuentran distribuidas
 las minas.
 Cada casilla del tablero puede estar en uno de dos estados: oculta o descubiert
a.
 Inicialmente, todas las casillas están ocultas, y los jugadores deben seleccion
ar casillas para descubrir su contenido.
\end_layout

\begin_layout Standard

\lang spanish
El número total de minas, representado por 
\begin_inset Formula $X$
\end_inset

, es conocido por los jugadores desde el inicio del juego.
 Sin embargo, la ubicación específica de las minas permanece oculta, lo
 que introduce incertidumbre y complejidad en el proceso de toma de decisiones.
\end_layout

\begin_layout Standard

\lang spanish
El objetivo del juego es descubrir todas las casillas que no contienen minas,
 evitando activar ninguna mina en el proceso.
 Para facilitar esta tarea, cada casilla del tablero revela un número que
 indica la cantidad de minas adyacentes a esa casilla.
 Esta información permite a los jugadores aplicar lógica y deducción para
 determinar la ubicación de las minas y evitar casillas peligrosas.
\end_layout

\begin_layout Standard

\lang spanish
El desafío del busca minas radica en encontrar soluciones óptimas que permitan
 completar el juego de manera eficiente y segura.
 Esto implica desarrollar estrategias y algoritmos que optimicen la selección
 de casillas para revelar, minimizando el riesgo de activar una mina y maximizan
do la certeza en la ubicación de las minas restantes.
\end_layout

\begin_layout Section

\lang spanish
Diseño
\end_layout

\begin_layout Definition*

\lang spanish
Entradas:
\end_layout

\begin_layout Definition*

\lang spanish
\begin_inset Formula $A=\begin{bmatrix}a_{11} & a_{12} & \cdots & a_{1M}\\
a_{21} & a_{22} & \cdots & a_{2M}\\
\vdots & \vdots & \ddots & \vdots\\
a_{N1} & a_{N2} & \cdots & a_{NM}
\end{bmatrix}$
\end_inset

, en donde 
\begin_inset Formula $\forall,a_{ij}\in\mathbb{N}$
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Definition*

\lang spanish
Salidas: 
\end_layout

\begin_layout Definition*

\lang spanish
\begin_inset Formula $Move=(i,j)$
\end_inset

, donde 
\begin_inset Formula $i$
\end_inset

 y 
\begin_inset Formula $j$
\end_inset

 son números naturales,
\begin_inset Formula $i,j∈N$
\end_inset

, que representan las coordenadas de fila y columna, respectivamente, del
 próximo movimiento en el juego.
\end_layout

\begin_layout Definition*
La tupla 
\begin_inset Formula $(i,j)$
\end_inset

 representa la casilla seleccionada para ser revelada en el tablero.
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Part

\lang spanish
Algoritmos
\end_layout

\begin_layout Section

\lang spanish
Opción algoritmo de fuerza bruta
\end_layout

\begin_layout Standard

\lang spanish
La estrategia de fuerza bruta para el juego de buscaminas implica probar
 todas las posibles combinaciones de casillas ocultas en el tablero, desde
 una casilla hasta todas las casillas disponibles.
 Para cada combinación generada, se simula el efecto de revelar las casillas
 correspondientes en el tablero y se verifica si esta situación conduce
 a una victoria en el juego.
 Este enfoque garantiza encontrar una solución correcta al problema, pero
 puede ser computacionalmente costoso, especialmente en tableros grandes,
 debido a la exhaustividad de la búsqueda.
\end_layout

\begin_layout Subsection

\lang spanish
Algoritmo
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

 
\begin_inset Formula $Combination\_player$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $ROWS,COLUMNS,MATRIX,FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $detect\_mines(ROWS,COLUMNS,MATRIX,FLAGGED\_MINES)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $unknown\_squares\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{i\leftarrow0}toROWS-1$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{j\leftarrow0}toCOLUMNS-1$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[i][j]='?'$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $unknown\_squares.append((\ensuremath{i},\ensuremath{j}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $check\_completed\_square(\ensuremath{i},\ensuremath{j})$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $detect\_mines(ROWS,COLUMNS,MATRIX,FLAGGED\_MINES)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $combination\_size\leftarrow1,\left|unknown\_squares+1)\right|$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $combination\in combinations(unknown\_squares,combination\_size)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $square\in combination$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $get\_index(square)\ensuremath{\notin}FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Return$
\end_inset

 
\begin_inset Formula $square$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $RandomPlayer()$
\end_inset

 
\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout
Combination_player
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

 Detect Mines 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $ROWS,COLUMNS,MATRIX,FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $options\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $i\leftarrow0\ensuremath{toROWS-1}$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{\ensuremath{j\leftarrow0}toCOLUMNS-1}$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[i][j]='?'$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $options.append((i,j))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $square\in options$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{i,j\leftarrow}square$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $num\_mines,adjacent\_squares\_list\ensuremath{\leftarrow}adjacent\_squares(\ensuremath{i},\ensuremath{j})$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $revealed\_adjacent\_squares\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{adj\_square\in revealed\_adjacent\_squares}$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[\ensuremath{x}][\ensuremath{y}]\ensuremath{\neq}'?''$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $revealed\_adjacent\_squares.append((\ensuremath{x},\ensuremath{y}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{x},\ensuremath{y})\in adjacent\_squares\_list$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $adj\_i,adj\_j\ensuremath{\leftarrow}adj\_square$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $adj\_num\_mines,adj\_adjacent\_squares\_list\ensuremath{\leftarrow}adjacent\_squares(adj\_i,adj\_j)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $unknown\_adjacent\_squares\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $(\ensuremath{x},\ensuremath{y})\in adj\_adjacent\_squares\_list$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[\ensuremath{x}][\ensuremath{y}]='?'$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $unknown\_adjacent\_squares.append((\ensuremath{x},\ensuremath{y}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $(unknown\_adjacent\_squares=adj\_num\_mines\mathcircumflex\left|unknown\_adjacent\_squares\right|>0\mathcircumflex get\_index(\ensuremath{i},\ensuremath{j})\notin FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $FLAGGED\_MINES.add(get\_index(\ensuremath{i},\ensuremath{j}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang spanish
Detect mines
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $check\_completed\_square$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{i},\ensuremath{j}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $num\_mines\ensuremath{\leftarrow}MATRIX[\ensuremath{i}][\ensuremath{j}]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $num,adjacent\_squares\_list\ensuremath{\leftarrow}adjacent\_squares(\ensuremath{i},\ensuremath{j})$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $flagged\_adjacent\_squares\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $(\ensuremath{x},\ensuremath{y})\in adjacent\_squares\_list$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $get\_index(\ensuremath{x},\ensuremath{y})\ensuremath{\in}FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $flagged\_adjacent\_squares.append((\ensuremath{x},\ensuremath{y}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $not\_flagged\_adjacent\_squares\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $(\ensuremath{x},\ensuremath{y})\in adjacent\_squares\_list$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $get\_index(\ensuremath{x},\ensuremath{y})\ensuremath{\notin}FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $not\_flagged\_adjacent\_squares.append((\ensuremath{x},\ensuremath{y}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\left|flagged\_adjacent\_squares\right|=num\_mines$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $limp\_square\in not\_flagged\_adjacent\_squares$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{x,y\leftarrow}limp\_square$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[\ensuremath{x}][\ensuremath{y}]="?"$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $mine\_hit\ensuremath{\leftarrow}update\_board(limp\_square)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang spanish
check _completed square
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\lang spanish
Complejidad
\end_layout

\begin_layout Standard

\lang spanish
El algoritmo de fuerza bruta para resolver problemas como Minesweeper se
 basa en generar todas las combinaciones posibles de las minas en el estado
 actual del tablero y verificar si cada configuración es válida.
 Asumiendo que el tablero puede ser de 
\begin_inset Formula $N×N$
\end_inset

 o 
\begin_inset Formula $N×M$
\end_inset

 y que hay 
\begin_inset Formula $k$
\end_inset

 minas, la complejidad se puede descomponer en varios pasos.
\end_layout

\begin_layout Standard

\lang spanish
Primero, el algoritmo genera todas las posibles configuraciones de minas
 en las celdas desconocidas.
 Si hay 
\begin_inset Formula $U$
\end_inset

 celdas desconocidas, el número de posibles configuraciones de 
\begin_inset Formula $k$
\end_inset

 minas es 
\begin_inset Formula $\left(C_{k}^{u}\right)$
\end_inset

.
 En el peor de los casos, donde todas las celdas son desconocidas ( 
\begin_inset Formula $U=N×M$
\end_inset

), el número de combinaciones posibles es exponencial: 
\begin_inset Formula $O(2^{U})$
\end_inset

.
 Esto se debe a que cada celda desconocida puede contener o no una mina,
 generando así 
\begin_inset Formula $2^{U}$
\end_inset

 combinaciones posibles.
\end_layout

\begin_layout Subsection

\lang spanish
Notas de implementación
\end_layout

\begin_layout Standard

\lang spanish
La implementación completa del código para resolver el problema de busca
 minas se puede encontrar en el repositorio de GitHub en el siguiente enlace:
 https://github.com/ALEYI17/busca_minas.
 Además, la entrega oficial del proyecto se ha realizado a través de la
 plataforma Brightspace de la Universidad Javeriana, donde se ha subido
 un archivo comprimido (zip) que contiene todos los archivos necesarios
 para la ejecución del código.
\end_layout

\begin_layout Section

\lang spanish
Opción algoritmo de heuristica
\end_layout

\begin_layout Subsection

\lang spanish
Algoritmo
\end_layout

\begin_layout Standard

\lang spanish
El funcionamiento del algoritmo heurístico se centra en la detección de
 casillas seguras y de riesgo en el tablero.
 Primero, identifica casillas donde se puede determinar con certeza que
 no hay minas, como aquellas con todas sus minas adyacentes marcadas o con
 un número igual al de casillas adyacentes desconocidas.
 Luego, evalúa las casillas de riesgo, que presentan un alto riesgo de contener
 minas según la distribución actual del tablero.
\end_layout

\begin_layout Standard

\lang spanish
Basándose en estas evaluaciones, el algoritmo decide qué casillas revelar
 a continuación para maximizar la información obtenida sobre el estado del
 tablero.
 Esto puede incluir la revelación de casillas seguras para avanzar de manera
 segura en el juego y la revelación de casillas de riesgo para reducir la
 incertidumbre sobre la presencia de minas.
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $information\_gained\_algorithm$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $ROWS,COLUMNS,MATRIX,FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $options\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $i\leftarrow0\ensuremath{toROWS-1}$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{\ensuremath{j\leftarrow0}toCOLUMNS-1}$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[\ensuremath{i}][\ensuremath{j}]\ensuremath{\neq}'?'$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $options.append((i,j))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $information\_gain\ensuremath{\leftarrow}\{\}$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $square\in options$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $get\_index(square)\ensuremath{\notin}FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{i,j\leftarrow}square$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $num\_mines,adjacent\_squares\_list\ensuremath{\leftarrow}adjacent\_squares(\ensuremath{i},\ensuremath{j})$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $unknown\_adjacent\_squares\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $(\ensuremath{x},\ensuremath{y})\in adjacent\_squares\_list$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[\ensuremath{x}][\ensuremath{y}]='?'$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $unknown\_adjacent\_squares.append((\ensuremath{x},\ensuremath{y}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $information\_gain[square]\ensuremath{\leftarrow}\left|unknown\_adjacent\_squares\right|$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $sorted\_information\_gain\ensuremath{\leftarrow}MergeSort(information\_gain.items())$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $sorted\_information\_gain\ensuremath{\leftarrow}MergeSort(information\_gain.items())$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $RETURN$
\end_inset

 
\begin_inset Formula $sorted\_information\_gain$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang spanish
information gained algorithm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $find\_play$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $sorted\_information\_gain,squ,FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $selected\_square\ensuremath{\leftarrow}squ$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $square,gain\in sorted\_information\_gain$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $num\_mines,adjacent\_squares\_list\ensuremath{\leftarrow}adjacent\_squares(square)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $unknown\_adjacent\_squares\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $(\ensuremath{x},\ensuremath{y})\in adjacent\_squares\_list$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[\ensuremath{x}][\ensuremath{y}]='?'$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $unknown\_adjacent\_squares.append((\ensuremath{x},\ensuremath{y}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $squad\in unknown\_adjacent\_squares$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $get\_index(squad)\ensuremath{\notin}FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $selected\_square\ensuremath{\leftarrow}squad$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Return$
\end_inset

 
\begin_inset Formula $selected\_square$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Return$
\end_inset

 
\begin_inset Formula $selected\_square$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang spanish
find play
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $heuristic\_player\_directed$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $ROWS,COLUMNS,MATRIX,FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $detect\_mines(ROWS,COLUMNS,MATRIX,FLAGGED\_MINES)$
\end_inset


\end_layout

\begin_layout Plain Layout

\size scriptsize
\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $sorted\_information\_gain$
\end_inset


\begin_inset Formula $\ensuremath{\leftarrow}$
\end_inset


\begin_inset Formula $information\_gained\_algorithm(sorted\_information\_gain,squ,FLAGGED\_MINES)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $selected\_square\ensuremath{\leftarrow}\textrm{Ø}$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $square,gain\in sorted\_information\_gain$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $selected\_square\ensuremath{\leftarrow}check\_completed\_square(square)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $detect\_mines(ROWS,COLUMNS,MATRIX,FLAGGED\_MINES)$
\end_inset


\end_layout

\begin_layout Plain Layout

\size scriptsize
\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $sorted\_information\_gain\ensuremath{\leftarrow}information\_gained\_algorithm(sorted\_information\_gain,squ,FLAGGED\_MINES)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $selected\_square\ensuremath{\leftarrow}find\_play(sorted\_information\_gain,selected\_square,FLAGGED\_MINES)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $selected\_square=\textrm{Ø}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $available\_squares\ensuremath{\leftarrow}[]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{i\leftarrow0}toROWS-1$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\ensuremath{j\leftarrow0}toCOLUMNS-1$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $MATRIX[\ensuremath{i}][\ensuremath{j}]='?'$
\end_inset


\begin_inset Formula $\wedge$
\end_inset


\begin_inset Formula $get\_index(\ensuremath{i},\ensuremath{j})\ensuremath{\notin}FLAGGED\_MINES$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $available\_squares.append((\ensuremath{i},\ensuremath{j}))$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $available\_squares$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $selected\_square\ensuremath{\leftarrow}random(available\_squares)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Return$
\end_inset

 
\begin_inset Formula $selected\_square$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang spanish
heuristic player
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\lang spanish
Complejidad
\end_layout

\begin_layout Standard

\lang spanish
La función check_completed_square verifica si una celda revelada ha identificado
 todas las minas a su alrededor y, si es así, marca las celdas seguras adyacente
s.
 La complejidad de esta función se desglosa de la siguiente manera: la llamada
 a adjacent_squares(i, j) se asume que es 
\begin_inset Formula $O(1)$
\end_inset

 ya que el número de celdas adyacentes es constante.
 La construcción de las listas flagged_adjacent_squares y not_flagged_adjacent_s
quares implica recorrer las celdas adyacentes, lo cual también es O(1).
 En el peor de los casos, update_board se llama para todas las celdas adyacentes
 no marcadas, lo cual también es 
\begin_inset Formula $O(1)$
\end_inset

 por celda adyacente.
 Por lo tanto, la complejidad total de esta función es 
\begin_inset Formula $O(1)$
\end_inset

 por celda, ya que se limita a las celdas adyacentes.
\end_layout

\begin_layout Standard

\lang spanish
La función detect_mines identifica celdas sospechosas de contener minas
 y las marca.
 La complejidad de esta función es la siguiente: la iteración doble sobre
 todas las celdas del tablero tiene una complejidad de 
\begin_inset Formula $O(N×M)$
\end_inset

 .
 La llamada a adjacent_squares por cada celda desconocida es 
\begin_inset Formula $O(1)$
\end_inset

.
 La construcción de las listas revealed_adjacent_squares y unknown_adjacent_squa
res es 
\begin_inset Formula $O(1)$
\end_inset

 por celda adyacente.
 La verificación de cada cuadrado adyacente revelado es 
\begin_inset Formula $O(1)$
\end_inset

.
 En total, la complejidad de esta función es 
\begin_inset Formula $O(N×M)$
\end_inset

.
\end_layout

\begin_layout Standard

\lang spanish
La función information_gained_algorithm evalúa la ganancia de información
 para cada celda revelada y ordena las celdas según esta métrica.
 Su complejidad es la siguiente: la iteración doble sobre todas las celdas
 del tablero es 
\begin_inset Formula $O(N×M)$
\end_inset

.
 La llamada a adjacent_squares y la construcción de unknown_adjacent_squares
 es 
\begin_inset Formula $O(1)$
\end_inset

 por celda adyacente.
 La ordenación de las celdas según la ganancia de información tiene una
 complejidad de 
\begin_inset Formula $O(UlogU)$
\end_inset

, donde 
\begin_inset Formula $U$
\end_inset

 es el número de celdas reveladas.
 Por lo tanto, la complejidad total de esta función es 
\begin_inset Formula $O(N×M$
\end_inset

, 
\end_layout

\begin_layout Standard

\lang spanish
La función find_play selecciona la siguiente jugada segura basada en la
 ganancia de información.
 Su complejidad es la siguiente: la iteración sobre la lista ordenada sorted_inf
ormation_gain tiene una complejidad de 
\begin_inset Formula $O(U)$
\end_inset

.
 La llamada a adjacent_squares y la construcción de unknown_adjacent_squares
 es 
\begin_inset Formula $O(1)$
\end_inset

 por celda adyacente.
 Por lo tanto, la complejidad total de esta función es 
\begin_inset Formula $O(U)$
\end_inset

.
\end_layout

\begin_layout Standard

\lang spanish
La función principal heuristic_player_directed coordina las funciones anteriores
 para hacer una jugada dirigida basada en la heurística.
 Su complejidad es la siguiente: cada llamada a detect_mines tiene una complejid
ad de 
\begin_inset Formula $O(N×M)$
\end_inset

.
 La llamada a information_gained_algorithm tiene una complejidad de 
\begin_inset Formula $O(N×M)$
\end_inset

.
 La iteración sobre sorted_information_gain para verificar celdas completadas
 es 
\begin_inset Formula $O(U)$
\end_inset

.
 La llamada a find_play tiene una complejidad de 
\begin_inset Formula $O(U)$
\end_inset

.
 En caso de no encontrar celdas seguras, la iteración para seleccionar una
 celda al azar es 
\begin_inset Formula $O(N×M)$
\end_inset

.
 Por lo tanto, la complejidad total del algoritmo es 
\begin_inset Formula $O(N×M)$
\end_inset

, ya que esta parte domina las otras complejidades.
\end_layout

\begin_layout Subsection

\lang spanish
Notas de implementación
\end_layout

\begin_layout Standard

\lang spanish
La implementación completa del código para resolver el problema de busca
 minas se puede encontrar en el repositorio de GitHub en el siguiente enlace:
 https://github.com/ALEYI17/busca_minas.
 Además, la entrega oficial del proyecto se ha realizado a través de la
 plataforma Brightspace de la Universidad Javeriana, donde se ha subido
 un archivo comprimido (zip) que contiene todos los archivos necesarios
 para la ejecución del código.
\end_layout

\begin_layout Part

\lang spanish
Comparación de los algoritmos
\end_layout

\begin_layout Standard

\lang spanish
Se comparan los resultados obtenidos por el algoritmo de fuerza bruta y
 el algoritmo heurístico aplicados a la resolución del juego Busca Minas.
 Ambos algoritmos abordan el problema desde enfoques distintos y, como tal,
 sus desempeños varían en términos de eficiencia y precisión.
\end_layout

\begin_layout Standard

\lang spanish
El algoritmo de fuerza bruta genera todas las posibles combinaciones de
 minas para el estado actual del tablero y verifica la validez de cada configura
ción.
 Este enfoque garantiza una solución precisa, ya que explora exhaustivamente
 todas las posibilidades.
 Sin embargo, su complejidad exponencial lo hace impráctico para tableros
 de gran tamaño o con muchas minas, debido al tiempo de ejecución extremadamente
 largo y al alto consumo de recursos computacionales.
\end_layout

\begin_layout Standard

\lang spanish
Por otro lado, el algoritmo heurístico utiliza un enfoque más inteligente
 para deducir celdas seguras basándose en la información revelada y en reglas
 heurísticas.
 Este algoritmo no garantiza encontrar siempre la solución correcta, pero
 es significativamente más eficiente en términos de tiempo de ejecución
 y uso de recursos.
 La heurística permite identificar rápidamente celdas seguras en la mayoría
 de los casos, lo que lo hace adecuado para tableros más grandes y situaciones
 más complejas.
\end_layout

\begin_layout Standard

\lang spanish
La comparación entre ambos algoritmos se realizará comparando sus tiempos
 de ejecución y los resultados obtenidos en términos del número de victorias.
 Para ello, se midió el tiempo de ejecución total de cada algoritmo y se
 realizaron simulaciones de 100 juegos para evaluar el porcentaje de victorias
 obtenidas por cada uno.
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename victorias.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparación
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Comparación victorias:
\end_layout

\begin_layout Standard

\lang spanish
Al analizar la gráfica que compara las victorias entre el algoritmo heurístico
 y el algoritmo de fuerza bruta, se destaca claramente que el algoritmo
 de fuerza bruta logró un mayor número de victorias, alcanzando aproximadamente
 un 60% de éxito en 100 simulaciones.
 Por otro lado, el algoritmo que utilizaba heurísticas obtuvo alrededor
 de 50 victorias, lo que indica que, aunque pierde más en comparación con
 el enfoque de fuerza bruta, sigue siendo una solución muy competitiva y
 efectiva.
\end_layout

\begin_layout Standard

\lang spanish
Este resultado era de esperar, dado que el enfoque de fuerza bruta examina
 exhaustivamente todas las posibilidades, lo que le permite encontrar soluciones
 precisas en un mayor número de casos.
 Mientras tanto, el algoritmo heurístico, si bien ofrece una solución más
 eficiente en términos de tiempo de ejecución, muestra una tasa de éxito
 ligeramente menor en comparación con el enfoque de fuerza bruta.
\end_layout

\begin_layout Paragraph

\lang spanish
Comparación tiempos:
\end_layout

\begin_layout Standard

\lang spanish
En la gráfica de tiempos se puede observar que, como se esperaba, el tiempo
 de ejecución del algoritmo de fuerza bruta es considerablemente mayor que
 el del algoritmo heurístico.
 Esto se debe a que el algoritmo de fuerza bruta examina todas las combinaciones
 posibles, lo que implica un mayor tiempo de procesamiento.
 En este caso particular, aunque el tiempo del algoritmo de fuerza bruta
 es más alto, es importante destacar que se reduce significativamente gracias
 a que solo se están considerando los espacios sin conocer adyacentes.
\end_layout

\begin_layout Standard

\lang spanish
En la gráfica, el algoritmo de fuerza bruta tiene una media de aproximadamente
 0.04 segundos, mientras que el algoritmo heurístico tiene un tiempo medio
 de ejecución de alrededor de 0.025 segundos.
 Esta diferencia en los tiempos de ejecución demuestra claramente la eficiencia
 del enfoque heurístico, que logra encontrar soluciones aceptables en un
 tiempo mucho más corto en comparación con el enfoque de fuerza bruta.
\end_layout

\begin_layout Standard

\lang spanish
La disparidad en los tiempos de ejecución entre ambos algoritmos era de
 esperarse debido a sus enfoques fundamentales.
 Mientras que el algoritmo de fuerza bruta realiza una exhaustiva exploración
 de todas las posibles combinaciones, el algoritmo heurístico utiliza reglas
 y estimaciones para tomar decisiones de manera más rápida y eficiente.
 A pesar de esta diferencia en complejidad computacional, el tiempo promedio
 de ejecución del algoritmo de fuerza bruta se mantiene en un nivel razonable
 gracias a la optimización que realiza al considerar solo los espacios adyacente
s desconocidos.
 Por otro lado, el algoritmo heurístico logra mantener un tiempo de ejecución
 significativamente menor, lo que demuestra su capacidad para encontrar
 soluciones aceptables en un tiempo más corto, aunque a costa de una menor
 precisión en algunos casos.
\end_layout

\begin_layout Part

\lang spanish
Conclusión
\end_layout

\begin_layout Standard

\lang spanish
La comparación entre los algoritmos de fuerza bruta y heurísticos para el
 juego de Busca Minas ofrece una visión interesante sobre la complejidad
 del problema.
 Es evidente que el juego de Busca Minas es un problema NP-completo, lo
 que significa que encontrar una solución óptima puede requerir un tiempo
 prohibitivamente largo en función del tamaño del tablero.
\end_layout

\begin_layout Standard

\lang spanish
El algoritmo de fuerza bruta proporciona una solución precisa y acertada
 al examinar exhaustivamente todas las combinaciones posibles.
 Sin embargo, esta precisión conlleva un costo significativo en términos
 de tiempo de ejecución, lo que puede limitar su aplicabilidad en casos
 donde se requiere una respuesta rápida.
\end_layout

\begin_layout Standard

\lang spanish
Por otro lado, el algoritmo heurístico ofrece una alternativa más eficiente
 en términos de tiempo de ejecución al utilizar reglas y estimaciones para
 tomar decisiones.
 Aunque su precisión puede ser menor en comparación con el enfoque de fuerza
 bruta, su capacidad para encontrar soluciones aceptables en un tiempo mucho
 más corto lo hace muy atractivo, especialmente en aplicaciones donde la
 rapidez es esencial.
\end_layout

\begin_layout Standard

\lang spanish
En conclusión, el uso de heurísticas proporciona una excelente forma de
 aproximar la solución del juego de Busca Minas y otros problemas similares.
 Si bien es posible que no ofrezcan una solución óptima en todos los casos,
 su tiempo computacional eficiente los convierte en una herramienta valiosa
 para abordar problemas complejos en la práctica.
\end_layout

\end_body
\end_document
